{"meta":{"title":"站在巨人的肩上","subtitle":"才能看得更远","description":"","author":"许炜烽","url":"http://www.xuweifeng.top","root":"/"},"pages":[{"title":"categories","date":"2020-04-04T03:17:13.000Z","updated":"2020-02-23T15:43:19.000Z","comments":true,"path":"categories/index.html","permalink":"http://www.xuweifeng.top/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-04-04T03:17:13.000Z","updated":"2020-02-23T15:40:51.000Z","comments":true,"path":"tags/index.html","permalink":"http://www.xuweifeng.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Mac下安装brew","slug":"12-Mac下安装brew","date":"2020-04-03T12:56:20.000Z","updated":"2020-04-03T13:04:03.000Z","comments":true,"path":"2020/04/03/12-Mac下安装brew/","link":"","permalink":"http://www.xuweifeng.top/2020/04/03/12-Mac%E4%B8%8B%E5%AE%89%E8%A3%85brew/","excerpt":"","text":"","categories":[],"tags":[{"name":"Mac-install","slug":"Mac-install","permalink":"http://www.xuweifeng.top/tags/Mac-install/"}]},{"title":"解决使用Better-Scroll产生的滚动bug","slug":"11-解决使用better-scroll产生的滚动bug","date":"2020-03-26T03:19:58.000Z","updated":"2020-03-26T14:06:37.000Z","comments":true,"path":"2020/03/26/11-解决使用better-scroll产生的滚动bug/","link":"","permalink":"http://www.xuweifeng.top/2020/03/26/11-%E8%A7%A3%E5%86%B3%E4%BD%BF%E7%94%A8better-scroll%E4%BA%A7%E7%94%9F%E7%9A%84%E6%BB%9A%E5%8A%A8bug/","excerpt":"","text":"1. 在使用Better-Scroll编写滚动区域时，，发现组件加载完图片后，多次发现可滚动区域有问题。然后通过console.log(scroll)打印scroll对象的属性，发现Better-Scroll在决定有多少区域可以滚动时, 是根据scrollerHeight属性决定.2. scrollerHeight属性是根据放Better-Scroll的content中的子组件的高度3. 但在首页中, 刚开始在计算scrollerHeight属性时, 是没有将图片计算在内的所以, 计算出来的高度会有错误！4. 后来图片加载进来之后有了新的高度, 但scrollerHeight属性并没有进行更新,因此滚动区域出现了问题.5. 解决这个滚动问题监听每一张图片是否加载完成, 只要有一张图片加载完成了, 执行一次refresh(),重新计算better-scroll.6. 如何监听图片加载完成了原生的js监听图片: img.onload = function() {}Vue中监听: @load=’方法’调用scroll的refresh()7. 如何将非父子组件的事件进行传递？因为涉及到非父子组件的通信, 所以这里我们选择了事件总线bus -&gt;总线Vue.prototype.$bus = new Vue()this.bus.emit(‘事件名称’, 参数)this.bus.on(‘事件名称’, 回调函数(参数))","categories":[],"tags":[{"name":"BScroll","slug":"BScroll","permalink":"http://www.xuweifeng.top/tags/BScroll/"}]},{"title":"组件使用better-scroll","slug":"10-关于better-scroll框架的使用","date":"2020-03-24T09:01:15.000Z","updated":"2020-03-26T03:26:01.000Z","comments":true,"path":"2020/03/24/10-关于better-scroll框架的使用/","link":"","permalink":"http://www.xuweifeng.top/2020/03/24/10-%E5%85%B3%E4%BA%8Ebetter-scroll%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"BetterScroll 中文文档链接https://ustbhuangyi.github.io/better-scroll/#/zh使用better-scroll的注意事项官方文档图绿色部分为 wrapper，也就是父容器，它会有固定的高度。黄色部分为 content，它是父容器的第一个子元素，它的高度会随着内容的大小而撑高。那么，当 content 的高度不超过父容器的高度，是不能滚动的，而它一旦超过了父容器的高度，我们就可以滚动内容区了，这就是 better-scroll 的滚动原理。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; .wrapper &#123; height: 200px; background-color: red; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt; &lt;div class=\"wrapper\"&gt; &lt;ul class=\"content\"&gt; &lt;button class=\"btn\"&gt;按钮&lt;/button&gt; &lt;li&gt;此li代替100行li&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;&lt;!-- 导入bscroll.js --&gt;&lt;script src=\"./bscroll.js\"&gt;&lt;/script&gt;&lt;script&gt; // 默认情况下BScroll是不可以实时的监听滚动位置 // probeType 侦测类型 // 0 、1 ：都是不侦测实时的位置 // 2 ：在手指滚动的过程中侦测, 手指离开后的惯性滚动过程中不侦测. // 3 ：只要是滚动, 都侦测. const bscroll = new BScroll(document.querySelector('.content'), &#123; probeType: 3, click: true, pullUpLoad: true &#125;) bscroll.on('scroll', (position) =&gt; &#123; // console.log(position); &#125;) bscroll.on('pullingUp', () =&gt; &#123; console.log('上拉加载更多'); // 发送网络请求, 请求更多页的数据 // 等数据请求完成, 并且将新的数据展示出来后 setTimeout(() =&gt; &#123; bscroll.finishPullUp() &#125;, 2000) &#125;) document.querySelector('.btn').addEventListener('click', function () &#123; console.log('触发点击！'); &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"BScroll","slug":"BScroll","permalink":"http://www.xuweifeng.top/tags/BScroll/"}]},{"title":"Axios的使用","slug":"09-axios的使用","date":"2020-03-17T12:47:58.000Z","updated":"2020-03-19T07:55:30.000Z","comments":true,"path":"2020/03/17/09-axios的使用/","link":"","permalink":"http://www.xuweifeng.top/2020/03/17/09-axios%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"Axios 的基本使用首先安装axiosnpm install axios --save通过inport 导入 axiosimport axios from &#39;axios&#39;基本使用123456789101112axios(&#123; // axios 返回一个Promise // 模拟地址 url: 'http://123.222.33.44:8000/test', // 若不传请求发送方式，默认为get请求. method: 'post'&#125;).then(res =&gt; &#123; console.log(res)&#125;)针对get请求的使用1234567891011axios(&#123; // 模拟地址 url: 'http://123.222.33.44:8000/api/home/data', // 专门针对get请求的参数拼接 params: &#123; type: 'new', page: 1 &#125;&#125;).then( res =&gt; &#123; console.log(res);&#125;)axios发送并发请求通过axios.all可以进行放入多个请求axios.all([]) 返回的结果是一个数组,使用axios.spread可将数组 [res1,res2]展开为 res1, res2.1234567891011121314151617181920212223// axios 提取全局配置 公共写到全局axios.defaults.baseURL = 'http://123.222.33.44:8000'axios.defaults.timeout = 5000axios.all([axios(&#123; // baseURL: 'http://123.222.33.44:8000', // timeout: 5, url: '/home/multidata',&#125;),axios(&#123; // baseURL: 'http://123.222.33.44:8000', // timeout: 5, url: '/api/home/data', params: &#123; type: 'new', page: 2 &#125;&#125;)]).then( axios.spread((res1, res2) =&gt; &#123; console.log(res1); console.log(res2);&#125;))全局配置在上面的示例中, 我们的BaseURL是固定的，在开发中可能很多参数都是固定的.这个时候我们可以进行一些抽取, 也可以利用axiox的全局配置.123axios.defaults.baseURL = ‘123.222.33.44:8000’axios.defaults.timeout = 5000// ......常见的配置选项请求地址： url: ‘/user’,请求类型： method: ‘get’,请根路径： baseURL: ‘http://www.mt.com/api&#39; ,请求前的数据处理： transformRequest:[function(data){}],请求后的数据处理： transformResponse: [function(data){}],自定义的请求头： headers:{‘x-Requested-With’:’XMLHttpRequest’},URL查询对象： params:{ id: 12 },查询对象序列化函数： paramsSerializer: function(params){ }request body： data: { key: ‘aa’},超时设置ms： timeout: 1000,跨域是否带Token： withCredentials: false,自定义请求处理： adapter: function(resolve, reject, config){},身份验证信息： auth: { uname: ‘’, pwd: ‘12’},响应的数据格式 json / blob /document /arraybuffer / text / stream： responseType: ‘json’,axios的实例为什么要创建axios的实例?当我们从axios模块中导入对象时, 使用的实例是默认的实例.当给该实例设置一些默认配置时, 这些配置就被固定下来了.但是后续开发中, 某些配置可能会不太一样.比如某些请求需要使用特定的baseURL或者timeout等.这个时候, 我们就可以创建新的实例, 并且传入属于该实例的配置信息.123456789101112131415161718192021222324252627282930313233// 创建实例instance1const instance1 = axios.create(&#123; baseURL: 'http://123.222.33.44:8000', timeout: 5000&#125;)// 创建实例instance2const instance2 = axios.create(&#123; baseURL: 'http://222.333.33.44:8000', timeout: 10000&#125;)instance1(&#123; url: '/home/multidata'&#125;).then(results =&gt; &#123; console.log(results);&#125;)instance1(&#123; url: '/api/home/data', params: &#123; type: 'new', page: 2 &#125;&#125;).then(results =&gt; &#123; console.log(results);&#125;)instance2(&#123; url: '/home/multidata'&#125;).then(results =&gt; &#123; console.log(results);&#125;)axios的封装通常我们的项目会越做越大,页面也会越来越多,如果页面非常的少,直接用axios也没有什么大的影响,那页面组件多了起来,上百个接口呢,这个时候后端改了接口,多加了一个参数什么的呢?那就只有找到那个页面,进去修改.整个过程很繁琐不易于项目的维护和迭代.这个时候如果我们统一的区管理接口,需要修改某一个接口的时候直接在api里修改对应的请求不是很方便，所以就可以进行针对封装.下面来简单实现axios的封装：封装代码12345678910111213import axios from 'axios'export function request(config) &#123; // 1.创建axios的实例 const instance = axios.create(&#123; baseURL: 'http://123.222.33.44:8000', timeout: 5000 &#125;) // 返回实例 // 由于axios返回的是一个Promise，所以可直接返回实例出去，在调用的时可直接使用 .then / .catch return instance(config)&#125;调用代码123456789import &#123;request&#125; from './network/request'request(&#123; url: '/home/multidata'&#125;).then( res =&gt; &#123; console.log(res);&#125;).catch(err =&gt; &#123; console.log(err);&#125;)axios拦截器请求成功 请求失败响应成功 响应失败拦截代码：1234567891011121314151617181920212223242526272829303132333435363738394041import axios from 'axios'export function request(config) &#123; // 1.创建axios的实例 const instance = axios.create(&#123; baseURL: 'http://123.207.32.32:8000', timeout: 5000 &#125;) // 2axios的拦截器 // 2.1 请求拦截 instance.interceptors.request.use(config =&gt; &#123; // 拦截使用场景 // config 中的一些信息不符合服务器的需求 需要过滤 // 每次发送网络请求时，都希望在界面中显示一个图标 // 某些网络请求（登录(token)），必须携带一些特殊的信息 console.log('请求成功拦截：' + config); // 拦截成功后需要返回出去 return config &#125;, err =&gt; &#123; console.log('请求失败拦截：' + err); &#125;) // 2.2 响应拦截 instance.interceptors.response.use(res =&gt; &#123; console.log('响应成功拦截：' + res) // 拦截成功后根据所需要的数据返回出去 return res.data &#125;, err =&gt; &#123; console.log('响应失败拦截：' + err) &#125;) // 3.发送网络请求 return instance(config)&#125;调用代码：123456789import &#123;request&#125; from './network/request'request(&#123; url: '/home/multidata'&#125;).then( res =&gt; &#123; console.log(res);&#125;).catch(err =&gt; &#123; console.log(err);&#125;)","categories":[],"tags":[{"name":"Axios","slug":"Axios","permalink":"http://www.xuweifeng.top/tags/Axios/"}]},{"title":"Vuex （二） 5 个核心基本使用","slug":"08-Vuex-二-5个属性","date":"2020-03-17T05:38:33.000Z","updated":"2020-03-31T14:56:49.000Z","comments":true,"path":"2020/03/17/08-Vuex-二-5个属性/","link":"","permalink":"http://www.xuweifeng.top/2020/03/17/08-Vuex-%E4%BA%8C-5%E4%B8%AA%E5%B1%9E%E6%80%A7/","excerpt":"","text":"Vuex 核心使用Vuex 的几个核心StateGettersMutationsActionModulesstate12345678910import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;&#125;)上面已定义好相关的属性值，现在来看看在组件中如何使用12345678910111213141516&lt;template&gt; &lt;h2&gt;&#123;&#123;$store.state.count&#125;&#125;&lt;/h2&gt; &lt;button @click=\"upDataCount\"&gt;修改Stote.state.count的值&lt;/button&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'App', data() &#123; return &#123;&#125; &#125;, components: &#123;&#125;, methods: &#123; upDataCount() &#123; this.$store.state.count = 10 &#125; &#125;&lt;/script&gt;getters当从我们从 State 获取到的数据时，有时候数据并不是我们直接想要的，而是需要经过相应的处理后，才能满足我们的需求，这个时候就可以使用 Getters。例： 从以下 State 中定义的 students 数组中获取年龄大于 20 的数组对象12345678910const store = new Vuex.Store(&#123; state: &#123; students: [ &#123;name: 'ABC1', age: 22 &#125; &#123;name: 'ABC2', age: 35 &#125; &#123;name: 'ABC3', age: 41 &#125; &#123;name: 'ABC4', age: 18 &#125; ] &#125;&#125;)在 Store 中定义 getters12345678910111213141516getters: &#123; // 获取年龄大于20的 getCount(state) &#123; return state.students.filter(s =&gt; s.age &gt; 20) &#125;, // 第二个参数可回调getters getAgeCountLen(state,getters) &#123; return getters.getCount.length &#125;, // 外部传入参数的使用方法 getAgeCount: state =&gt; &#123; return Age =&gt; &#123; return state.students.filter( s =&gt; s.age &gt; Age) &#125; &#125;&#125;那么如何在组件中获取到并展示呢？ 下面来看代码12345678910&lt;template&gt; &lt;!--获取年龄大于20的数组对象--&gt; &lt;h2&gt;&#123;&#123;$store.getters.getCount&#125;&#125;&lt;/h2&gt; &lt;!--获取年龄大于20的数组对象的长度--&gt; &lt;h2&gt;&#123;&#123;$store.getters.getCountLen&#125;&#125;&lt;/h2&gt; &lt;!--获取年龄大于30的数组对象--&gt; &lt;h2&gt;&#123;&#123;$store.getters.getAgeCount(30)&#125;&#125;&lt;/h2&gt;&lt;/template&gt;mutationsMutation 状态更新Vuex 的 store 状态的更新唯一方式：提交 MutationMutation 主要包括两部分：字符串的事件类型（type）一个回调函数（handler）, 该回调函数的第一个参数就是 state。mutation 的定义方式：12345mutations: &#123; increment(state) &#123; state.count++ &#125;&#125;通过 mutation 更新123increment: funciton() &#123; this.$store.commit('increment')&#125;Mutation 传递参数在通过 mutation 更新数据的时候，有可能我们希望携带一些额外的参数参数被称为是 mutation 的载荷 (Payload)Mutation 中的代码：12345678// Mutation 中的代码： decrement(state, n)&#123; state.count += n &#125;// 组件 中的代码： drement: function() &#123; this.$store.commit('decrement', 2) &#125;Mutation常量类型创建一个文件: mutation-types.js, 并且在其中定义我们的常量.定义常量时, 可以使用ES2015中的风格, 使用一个常量来作为函数的名称.Mutation常量类型 – 代码不要在Mutation中进行异步操作.在Vuex中进行一些异步操作, 比如网络请求, 必然是异步的. 这个时候可以使用Action来代替Mutation进行异步操作的.ActionsAction返回的Promise进行异步操作在Action中, 我们可以将异步操作放在一个Promise中, 并且在成功或者失败后, 调用对应的resolve或reject.ModulesModule局部状态具体的局部模块中的代码如下书写.我们在moduleA中添加state、mutations、gettersmutation和getters接收的第一个参数是局部状态对象Actions的参数写法接收一个context参数对象局部状态通过 context.state 暴露出来，根节点状态则为 context.rootState如果getters中也需要使用全局的状态, 可以接受更多的参数项目结构Vuex管理过多当内容时，可将上面当核心属性进行抽离管理，方便维护","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://www.xuweifeng.top/tags/Vue/"},{"name":"Vuex","slug":"Vuex","permalink":"http://www.xuweifeng.top/tags/Vuex/"}]},{"title":"关于箭头函数中的this","slug":"07-关于箭头函数中的this","date":"2020-03-10T14:16:05.000Z","updated":"2020-03-10T14:54:55.000Z","comments":true,"path":"2020/03/10/07-关于箭头函数中的this/","link":"","permalink":"http://www.xuweifeng.top/2020/03/10/07-%E5%85%B3%E4%BA%8E%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84this/","excerpt":"","text":"一.箭头函数本身不创建this箭头函数本身没有this，但是在它声明时可以捕获别人的this供自己使用。123456789&lt;script&gt; setTimeout(function() &#123; console.log(this) // 指向window &#125;,1000) setTimeout( () =&gt; &#123; console.log(this) // 指向window &#125;)&lt;/script&gt;二.作用域中的this箭头函数中的this是通过捕获而来箭头函数中的this是在它声明时捕获它所处作用域中的this。下面通过代码实例演示一下：1234567891011121314151617&lt;script&gt;const obj = &#123; test () &#123; //通过call 传来一个window setTimeout(function() &#123; console.log(this); // window &#125;) //箭头函数中的this是如何查找的 ? //向外层作用域中，一层层查找this 直到有this的定义 setTimeout( () =&gt; &#123; console.log(this); // test 指向obj中的对象 &#125;) &#125;&#125;obj.test()&lt;/script&gt;&#125;123456789101112131415161718192021222324252627&lt;script&gt;const obj = &#123; test () &#123; setTimeout(function() &#123; setTimeout(function() &#123; console.log(this); // window &#125;) setTimeout( () =&gt; &#123; console.log(this); // window &#125;) &#125;) setTimeout( () =&gt; &#123; setTimeout(function() &#123; console.log(this) // window &#125;) setTimeout(() =&gt; &#123; console.log(this) // test &#125;) &#125;) &#125;&#125;obj.test()&lt;/script&gt;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.xuweifeng.top/tags/JavaScript/"}]},{"title":"vue初体验","slug":"06-vue初体验","date":"2020-03-04T05:31:24.000Z","updated":"2020-03-10T14:54:56.000Z","comments":true,"path":"2020/03/04/06-vue初体验/","link":"","permalink":"http://www.xuweifeng.top/2020/03/04/06-vue%E5%88%9D%E4%BD%93%E9%AA%8C/","excerpt":"","text":"Vue编程范式属于声明式编程初始编写1234567891011121314&lt;body&gt; &lt;div id=\"app\"&gt; &lt;!-- 被管理的元素--&gt; &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;/div&gt; &lt;script src=\"./vue.js\"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: '#app', //用于挂载要管理的元素 data: &#123; // 定义数据 message: 'hello!' &#125; &#125;) &lt;/script&gt;&lt;body&gt;阅读以上代码，可以发现创建来一个Vue对象。对象里面传入了一些options：{ }el： 该属性决定这个Vue对象挂载到哪一个元素上 ，上面代码可以看出是挂载到了app到元素上。data： 该属性是存储一些数据。数据来源可是直接定义出来的。数据来源也可以是来自网络， 从服务器加载来。当数据发生改变的时候，页面会自动发生响应。","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://www.xuweifeng.top/tags/Vue/"}]},{"title":"Vuex (一)","slug":"05-Vuex-一-简单认识","date":"2020-02-27T14:19:09.000Z","updated":"2020-03-17T05:39:52.000Z","comments":true,"path":"2020/02/27/05-Vuex-一-简单认识/","link":"","permalink":"http://www.xuweifeng.top/2020/02/27/05-Vuex-%E4%B8%80-%E7%AE%80%E5%8D%95%E8%AE%A4%E8%AF%86/","excerpt":"","text":"认识VuexVuex是什么？官方解释：Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用 集中式存储管理 应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。状态管理是什么？状态管理模式、集中式存储管理这些名词听起来就非常高大上，让人捉摸不透。但可以简单的将其看成把需要多个组件共享的变量全部存储在一个对象里面。然后，将这个对象放在顶层的Vue实例中，让其他组件可以使用。那这样带来但便利是什么呢？其目的就是为了响应式，Vuex就是为了提供这样一个在多个组件间共享状态的插件，用它！用它！用它！管理什么状态呢?有什么状态时需要我们在多个组件间共享的呢？在做过大型开发时，一定遇到过多个状态，在多个界面间的共享问题。比如用户的登录状态、用户名称、头像、地理位置信息等等。比如商品的收藏、购物车中的物品等等。这些状态信息，我们都可以放在统一的地方，对它进行保存和管理，而且它们还是响应式的单界面的状态管理我们知道，要在单个组件中进行状态管理是一件非常简单的事情。什么意思呢？我们来看下面的图片。这图片中的三种东西，怎么理解呢？State：不用多说，就是我们的状态。（你姑且可以当做就是data中的属性）View：视图层，可以针对State的变化，显示不同的信息。（这个好理解吧？）Actions：这里的Actions主要是用户的各种操作：点击、输入等等，会导致状态的改变。下面写点代码，来加深理解吧！12345678910111213141516171819202122 &lt;template&gt; &lt;div&gt; &lt;div&gt;当前计数：&#123;&#123;counter&#125;&#125;&lt;/div&gt; &lt;button @click=\"counter++\"&gt;+1&lt;/button&gt; &lt;button @click=\"counter--\"&gt;-1&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: 'HelloVuex', data() &#123; return &#123; counter: 0 &#125; &#125;, &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;让我们来通过上面的代码来了解一下流程图吧在这个案例中，我们有没有状态需要管理呢？没错，就是个数counter。counter需要某种方式被记录下来，也就是我们的State。counter目前的值需要被显示在界面中，也就是我们的View部分。界面发生某些操作时（我们这里是用户的点击，也可以是用户的input），需要去更新状态，也就是我们的Actions多界面状态管理Vue已经帮我们做好了单个界面的状态管理，但是如果是多个界面呢？多个试图都依赖同一个状态（一个状态改了，多个界面需要进行更新）不同界面的Actions都想修改同一个状态（Home.vue需要修改，Profile.vue也需要修改这个状态）也就是说对于某些状态(状态1/状态2/状态3)来说只属于我们某一个试图，但是也有一些状态(状态a/状态b/状态c)属于多个试图共同想要维护的状态1/状态2/状态3你放在自己的房间中，你自己管理自己用，没问题。但是状态a/状态b/状态c我们希望交给一个大管家来统一帮助我们管理！！！没错，Vuex就是为我们提供这个大管家的工具。全局单例模式（大管家）我们现在要做的就是将共享的状态抽取出来，交给我们的大管家，统一进行管理。之后，你们每个试图，按照我规定好的规定，进行访问和修改等操作。这就是Vuex背后的基本思想。Vuex状态管理图例官方图片在图例中，Vue官方建议我们通过Vue Components到action，然后在Mutations中修改我们的State，Vue官方不建议我们直接修改State，否则Devtools这个官方给我们提供的浏览器调试工具就无法跟踪是哪一个组件修改了State，不利于我们项目的管理。我们可以直接通过Mutations修改State，而Actions主要做异步操作（向后端发送网络请求），Mutations中主要是做同步操作。Vuex的基本使用简单的案例1. 引入Vuex首先，我们需要在某个地方存放我们的Vuex代码,这里，我们先创建一个文件夹store，并且在其中创建一个index.js文件,在index.js文件中写入如下代码：1234567891011121314151617181920212223import Vue from 'vue'import Vuex from 'vuex'// 1. 安装插件Vue.use(Vuex)// 2. 创建对象const store = new Vuex.Store(&#123; state: &#123; counter: 0, &#125;, mutations: &#123; increment(state) &#123; state.counter++ &#125;, decrement(state) &#123; state.counter-- &#125; &#125;&#125;)// 3.导出store对象export default store2. 挂载到Vue实例中其次，我们让所有的Vue组件都可以使用这个store对象，来到main.js文件，导入store对象，并且放在new Vue中，这样，在其他Vue组件中，我们就可以通过this.$store的方式，获取到这个store对象了。123456789101112import Vue from &#39;vue&#39;import App from &#39;.&#x2F;App&#39;import store from &#39;.&#x2F;store&#39;Vue.config.productionTip &#x3D; false&#x2F;* eslint-disable no-new *&#x2F;new Vue(&#123; el: &#39;#app&#39;, store, render: h &#x3D;&gt; h(App)&#125;)3. 使用Vuex的count12345678910111213141516171819202122232425262728293031&lt;template&gt; &lt;div&gt; &lt;h2&gt;&#123;&#123;$store.state.counter&#125;&#125;&lt;/h2&gt; &lt;h2&gt;&#123;&#123;counter&#125;&#125;&lt;/h2&gt; &lt;button @click=\"increment\"&gt;+1&lt;/button&gt; &lt;button @click=\"decrement\"&gt;-1&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: 'HelloVuex', computed: &#123; counter() &#123; return this.$store.state.counter &#125; &#125;, methods: &#123; increment() &#123; this.$store.commit('increment') &#125;, decrement() &#123; this.$store.commit('decrement') &#125; &#125;, &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;好的，这就是使用Vuex最简单的方式了。我们来对使用步骤，做一个简单的小节：1.提取出一个公共的store对象，用于保存在多个组件中共享的状态2.将store对象放置在new Vue对象中，这样可以保证在所有的组件中都可以使用到3.在其他组件中使用store对象中保存的状态即可通过this.$store.state.属性的方式来访问状态通过this.$store.commit(‘mutation中方法’)来修改状态注意事项：我们通过提交mutation的方式，而非直接改变store.state.count。这是因为Vuex可以更明确的追踪状态的变化，所以不要直接改变store.state.count的值。参考coderwhy","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://www.xuweifeng.top/tags/Vue/"},{"name":"Vuex","slug":"Vuex","permalink":"http://www.xuweifeng.top/tags/Vuex/"}]},{"title":"Promise","slug":"04-Promise","date":"2020-02-26T15:44:04.000Z","updated":"2020-02-26T17:05:46.000Z","comments":true,"path":"2020/02/26/04-Promise/","link":"","permalink":"http://www.xuweifeng.top/2020/02/26/04-Promise/","excerpt":"","text":"Promise是什么？Promise是异步编程的一种解决方案，ES6中一个非常重要和好用的特性。常见的使用场景是网络请求，当网络请求非常复杂时，就会出回调地狱(见下图)夸张案例然而Promise可以以一种非常优雅的方式来解决这个问题。认识基本语法123456789101112//利用 setTimeout 来模拟 ajax 请求new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; // 成功调用 resolve('Hello world !') // 失败调用 reject(\"error message !\") &#125;,1000)&#125;).then(data =&gt; &#123; console.log(data);&#125;).catch(err =&gt; &#123; console.log(err);)以上通过new Promise创建了一个Promise对象。通常情况下，会根据请求数据的成功和失败来决定调用哪一个。如果是成功的，那么通常会调用resolve(messsage)，这个时候，后续的then会被回调。如果是失败的，那么通常会调用reject(error)，这个时候，后续的catch会被回调。Promise的三种状态在我们开发中有异步操作时, 可以给异步操作包装一个Promise，异步操作之后会有三种状态。pending：等待状态，比如正在进行网络请求，或者定时器没有到时间。fulfill：满足状态，当主动回调了resolve时，就处于该状态，并且会回调.then()。reject：拒绝状态，当主动回调了reject时，就处于该状态，并且会回调.catch()。Promise的链式调用执行then还是catch的时候都可以返回一个Promise对象，代码是可以进行链式调用的。Promise.resovle()：将数据包装成Promise对象，并且在内部回调resolve()函数。Promise.reject()：将数据包装成Promise对象，并且在内部回调reject()函数。Promis的all方法使用12345678910111213141516//发送两次或多次请求可用Promise.call方法 Promise.all([ new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#123;name:'abc', age:18&#125;) //可对象 可字符串 &#125;,2000) &#125;), new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve('result 2 !') //可对象 可字符串 &#125;,2000) &#125;), ]).then(results =&gt; &#123; console.log(results); //返回一个数组来保存 &#125;)参考coderwhy","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.xuweifeng.top/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://www.xuweifeng.top/tags/ES6/"}]},{"title":"Vue的生命周期","slug":"03-Vue的生命周期","date":"2020-02-25T11:37:20.000Z","updated":"2020-02-26T16:12:40.000Z","comments":true,"path":"2020/02/25/03-Vue的生命周期/","link":"","permalink":"http://www.xuweifeng.top/2020/02/25/03-Vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","excerpt":"","text":"生命周期图示new Vue——&gt;创建一个vue实例init()——&gt;初始化空的vue对象beforecreate——&gt;data &amp; methods 还未初始化created——&gt;data &amp; methods 已经初始化好，此时可调用methods方法、使用data中的数据(最早)compile template——&gt;编译模板在内存中生成DOM树，但此时未加载到页面上beforeMount——&gt;模板尚未挂载至页面，页面仍未更新create vm.$el &amp; replace el with it——&gt;将内存中编译好的模板替换至页面上,此时可操作页面Dom(最早)mounted——&gt;实例初始化加载完毕，进入运行阶段beforeUpdate——&gt;data changed,data中数据已更新，页面上的数据仍未更新virtual DOM re-render and patch——&gt;根据data的数据在内存中重新渲染新DOM树，更新完毕再将其渲染到页面- (model—&gt;view)updated——&gt;页面中的data更新了beforeDestroy——&gt;运行—&gt;销毁，此时data/methods等仍可用，并未真正销毁destroyed——&gt;everything is null","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://www.xuweifeng.top/tags/Vue/"},{"name":"前端框架","slug":"前端框架","permalink":"http://www.xuweifeng.top/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"}]},{"title":"邂逅Vuejs","slug":"02-邂逅Vuejs","date":"2020-02-25T10:30:26.000Z","updated":"2020-02-26T16:15:37.000Z","comments":true,"path":"2020/02/25/02-邂逅Vuejs/","link":"","permalink":"http://www.xuweifeng.top/2020/02/25/02-%E9%82%82%E9%80%85Vuejs/","excerpt":"","text":"简单认识Vuejs为什么要学习Vuejs？招聘前端的需求中，10个有8个都对Vue有或多或少的要求。当然，作为学习者我们知道Vuejs目前非常火，可以说是前端必备的一个技能。近两年前端技术变革速度太快，vue不论针对web项目开发，网站制作，还是app，小程序开发，都越来越流行，其便捷性及易用程度都让你不得不考虑去学习。Vuejs是什么？Vue是一个渐进式的框架，那什么是渐进式的呢？渐进式意味着你可以将Vue作为你应用的一部分嵌入其中，带来更丰富的交互体验。或者如果你希望将更多的业务逻辑使用Vue实现，那么Vue的核心库以及其生态系统。比如Core+Vue-router+Vuex，也可以满足你各种各样的需求。Vue有很多特点和Web开发中常见的高级功能解耦视图和数据可复用的组件前端路由技术状态管理虚拟DOM学习Vuejs的前提？需具备一定的HTML、CSS、JavaScript基础。开始Vue.js之旅Vue.js安装使用一个框架之前我们要下载安装它。方式一：直接CDN引入12345&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt; &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;&lt;!-- 生产环境版本，优化了尺寸和速度 --&gt;&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue&quot;&gt;&lt;&#x2F;script&gt;方式二：下载和引入开发环境 https://vuejs.org/js/vue.js生产环境 https://vuejs.org/js/vue.min.js方式三：NPM安装","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://www.xuweifeng.top/tags/Vue/"},{"name":"前端框架","slug":"前端框架","permalink":"http://www.xuweifeng.top/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"}]},{"title":"关于搭建此博客","slug":"01-此博客的搭建","date":"2020-02-23T13:32:50.000Z","updated":"2020-02-26T16:08:46.000Z","comments":true,"path":"2020/02/23/01-此博客的搭建/","link":"","permalink":"http://www.xuweifeng.top/2020/02/23/01-%E6%AD%A4%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/","excerpt":"","text":"搭建前工作写作工具MarkDownMarkdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。语法简洁明了、学习容易，而且功能比纯文本更强。搭建平台Github PagesGitHub Pages旨在从GitHub存储库托管您的个人，组织或项目页面。面对全球最大的开源社区,用户生态良好国内访问速度慢框架主题HexoHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。插件丰富,拓展性强hexo-theme-material-indigoMaterial Design 风格的Hexo主题，基于 Hexo 3.0+ 制作。去jQuery化以提高代码速度,更加相信现代浏览器的原生兼容性准备工具Git用来管理博客代码Node.jsHexo基于Node.js开发,下载Hexo及其主题与插件都需要用到其中的npm工具开始搭建所有的命令指令都需要在Hexo根目录下执行安装hexo框架打开命令行(管理者模式),通过npm工具下载hexo框架npm install hexo-cli -g创建一个blog文件夹,并在这个文件夹中初始化一个hexo框架hexo init blog进入blog文件夹,也就是整个Hexo站点的根目录cd blog安装hexo所需要的文件npm install启动hexohexo server #简写 hexo s通过http://localhost:4000/在浏览器中访问生成的博客目录结构_config.yml： //Hexo配置文件,网站的配置信息node_modules： //依赖包public： //存放生成的页面scaffolds： //生成文章的一些模板themes： //存放主题包source： //用来存放你的文章_drafts： //草稿_posts： //文章Hexo配置在文件根目录下的_config.yml文件配置，详细参考官方的配置描述。indigo安装与配置indigo安装使用git命令，执行以下命令安装git clone https://github.com/yscoder/hexo-theme-indigo.git安装完打开themes文件夹可看见相对于的主题文件打开根目录下的_config.yml对theme属性编辑theme: indigo #这里填写的主题名字在命令行输入hexo g 生成静态文件再输入hexo s进行重启服务器通过http://localhost:4000/在浏览器中访问生成的主题博客indigo配置修改主题目录下的_config.yml文件,详细可参考主题作者的配置说明描述。部署到GitHub Pageshexo clean #清除本地缓存,也可以跳过这一步hexo generate #生成静态资源 简写:hexo ghexo deploy #部署资源 简写:hexo d","categories":[],"tags":[{"name":"Blog","slug":"Blog","permalink":"http://www.xuweifeng.top/tags/Blog/"}]}]}