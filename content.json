{"meta":{"title":"站在巨人的肩上","subtitle":"才能看得更远","description":"","author":"许炜烽","url":"http://www.xuweifeng.top","root":"/"},"pages":[{"title":"categories","date":"2020-02-23T15:46:28.000Z","updated":"2020-02-23T15:43:19.000Z","comments":true,"path":"categories/index.html","permalink":"http://www.xuweifeng.top/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-02-23T15:46:28.000Z","updated":"2020-02-23T15:40:51.000Z","comments":true,"path":"tags/index.html","permalink":"http://www.xuweifeng.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"关于箭头函数中的this","slug":"关于箭头函数中的this","date":"2020-03-10T14:16:05.000Z","updated":"2020-03-10T14:54:55.000Z","comments":true,"path":"2020/03/10/关于箭头函数中的this/","link":"","permalink":"http://www.xuweifeng.top/2020/03/10/%E5%85%B3%E4%BA%8E%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84this/","excerpt":"","text":"一.箭头函数本身不创建this箭头函数本身没有this，但是在它声明时可以捕获别人的this供自己使用。 123456789&lt;script&gt; setTimeout(function() &#123; console.log(this) // 指向window &#125;,1000) setTimeout( () =&gt; &#123; console.log(this) // 指向window &#125;)&lt;/script&gt; 二.作用域中的this箭头函数中的this是通过捕获而来 箭头函数中的this是在它声明时捕获它所处作用域中的this。 下面通过代码实例演示一下： 1234567891011121314151617&lt;script&gt;const obj = &#123; test () &#123; //通过call 传来一个window setTimeout(function() &#123; console.log(this); // window &#125;) //箭头函数中的this是如何查找的 ? //向外层作用域中，一层层查找this 直到有this的定义 setTimeout( () =&gt; &#123; console.log(this); // test 指向obj中的对象 &#125;) &#125;&#125;obj.test()&lt;/script&gt;&#125; 123456789101112131415161718192021222324252627&lt;script&gt;const obj = &#123; test () &#123; setTimeout(function() &#123; setTimeout(function() &#123; console.log(this); // window &#125;) setTimeout( () =&gt; &#123; console.log(this); // window &#125;) &#125;) setTimeout( () =&gt; &#123; setTimeout(function() &#123; console.log(this) // window &#125;) setTimeout(() =&gt; &#123; console.log(this) // test &#125;) &#125;) &#125;&#125;obj.test()&lt;/script&gt;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.xuweifeng.top/tags/JavaScript/"}]},{"title":"vue初体验","slug":"vue初体验","date":"2020-03-04T05:31:24.000Z","updated":"2020-03-10T14:54:56.000Z","comments":true,"path":"2020/03/04/vue初体验/","link":"","permalink":"http://www.xuweifeng.top/2020/03/04/vue%E5%88%9D%E4%BD%93%E9%AA%8C/","excerpt":"","text":"Vue编程范式属于声明式编程 初始编写1234567891011121314&lt;body&gt; &lt;div id=\"app\"&gt; &lt;!-- 被管理的元素--&gt; &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;/div&gt; &lt;script src=\"./vue.js\"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: '#app', //用于挂载要管理的元素 data: &#123; // 定义数据 message: 'hello!' &#125; &#125;) &lt;/script&gt;&lt;body&gt; 阅读以上代码，可以发现创建来一个Vue对象。 对象里面传入了一些options：{ } el： 该属性决定这个Vue对象挂载到哪一个元素上 ，上面代码可以看出是挂载到了app到元素上。 data： 该属性是存储一些数据。 数据来源可是直接定义出来的。 数据来源也可以是来自网络， 从服务器加载来。 当数据发生改变的时候，页面会自动发生响应。","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://www.xuweifeng.top/tags/Vue/"}]},{"title":"Vuex","slug":"Vuex的详解","date":"2020-02-27T14:19:09.000Z","updated":"2020-02-27T15:17:37.000Z","comments":true,"path":"2020/02/27/Vuex的详解/","link":"","permalink":"http://www.xuweifeng.top/2020/02/27/Vuex%E7%9A%84%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"认识VuexVuex是什么？官方解释：Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。 它采用 集中式存储管理 应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 Vuex 也集成到 Vue 的官方调试工具 devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。 状态管理是什么？状态管理模式、集中式存储管理这些名词听起来就非常高大上，让人捉摸不透。但可以简单的将其看成把需要多个组件共享的变量全部存储在一个对象里面。然后，将这个对象放在顶层的Vue实例中，让其他组件可以使用。那这样带来但便利是什么呢？其目的就是为了响应式，Vuex就是为了提供这样一个在多个组件间共享状态的插件，用它！用它！用它！ 管理什么状态呢?有什么状态时需要我们在多个组件间共享的呢？在做过大型开发时，一定遇到过多个状态，在多个界面间的共享问题。 比如用户的登录状态、用户名称、头像、地理位置信息等等。 比如商品的收藏、购物车中的物品等等。 这些状态信息，我们都可以放在统一的地方，对它进行保存和管理，而且它们还是响应式的 单界面的状态管理我们知道，要在单个组件中进行状态管理是一件非常简单的事情。什么意思呢？我们来看下面的图片。 这图片中的三种东西，怎么理解呢？ State：不用多说，就是我们的状态。（你姑且可以当做就是data中的属性） View：视图层，可以针对State的变化，显示不同的信息。（这个好理解吧？） Actions：这里的Actions主要是用户的各种操作：点击、输入等等，会导致状态的改变。 下面写点代码，来加深理解吧！ 12345678910111213141516171819202122 &lt;template&gt; &lt;div&gt; &lt;div&gt;当前计数：&#123;&#123;counter&#125;&#125;&lt;/div&gt; &lt;button @click=\"counter++\"&gt;+1&lt;/button&gt; &lt;button @click=\"counter--\"&gt;-1&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: 'HelloVuex', data() &#123; return &#123; counter: 0 &#125; &#125;, &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 让我们来通过上面的代码来了解一下流程图吧 在这个案例中，我们有没有状态需要管理呢？没错，就是个数counter。 counter需要某种方式被记录下来，也就是我们的State。 counter目前的值需要被显示在界面中，也就是我们的View部分。 界面发生某些操作时（我们这里是用户的点击，也可以是用户的input），需要去更新状态，也就是我们的Actions 多界面状态管理 Vue已经帮我们做好了单个界面的状态管理，但是如果是多个界面呢？ 多个试图都依赖同一个状态（一个状态改了，多个界面需要进行更新） 不同界面的Actions都想修改同一个状态（Home.vue需要修改，Profile.vue也需要修改这个状态） 也就是说对于某些状态(状态1/状态2/状态3)来说只属于我们某一个试图，但是也有一些状态(状态a/状态b/状态c)属于多个试图共同想要维护的 状态1/状态2/状态3你放在自己的房间中，你自己管理自己用，没问题。 但是状态a/状态b/状态c我们希望交给一个大管家来统一帮助我们管理！！！ 没错，Vuex就是为我们提供这个大管家的工具。 全局单例模式（大管家） 我们现在要做的就是将共享的状态抽取出来，交给我们的大管家，统一进行管理。 之后，你们每个试图，按照我规定好的规定，进行访问和修改等操作。 这就是Vuex背后的基本思想。 Vuex状态管理图例 官方图片 在图例中，Vue官方建议我们通过Vue Components到action，然后在Mutations中修改我们的State， Vue官方不建议我们直接修改State，否则Devtools这个官方给我们提供的浏览器调试工具就无法跟踪是哪一个组件修改了State，不利于我们项目的管理。 我们可以直接通过Mutations修改State，而Actions主要做异步操作（向后端发送网络请求），Mutations中主要是做同步操作。 Vuex的基本使用 简单的案例 1. 引入Vuex首先，我们需要在某个地方存放我们的Vuex代码,这里，我们先创建一个文件夹store，并且在其中创建一个index.js文件,在index.js文件中写入如下代码： 1234567891011121314151617181920212223import Vue from 'vue'import Vuex from 'vuex'// 1. 安装插件Vue.use(Vuex)// 2. 创建对象const store = new Vuex.Store(&#123; state: &#123; counter: 0, &#125;, mutations: &#123; increment(state) &#123; state.counter++ &#125;, decrement(state) &#123; state.counter-- &#125; &#125;&#125;)// 3.导出store对象export default store 2. 挂载到Vue实例中其次，我们让所有的Vue组件都可以使用这个store对象，来到main.js文件，导入store对象，并且放在new Vue中，这样，在其他Vue组件中，我们就可以通过this.$store的方式，获取到这个store对象了。 123456789101112import Vue from &#39;vue&#39;import App from &#39;.&#x2F;App&#39;import store from &#39;.&#x2F;store&#39;Vue.config.productionTip &#x3D; false&#x2F;* eslint-disable no-new *&#x2F;new Vue(&#123; el: &#39;#app&#39;, store, render: h &#x3D;&gt; h(App)&#125;) 3. 使用Vuex的count12345678910111213141516171819202122232425262728293031&lt;template&gt; &lt;div&gt; &lt;h2&gt;&#123;&#123;$store.state.counter&#125;&#125;&lt;/h2&gt; &lt;h2&gt;&#123;&#123;counter&#125;&#125;&lt;/h2&gt; &lt;button @click=\"increment\"&gt;+1&lt;/button&gt; &lt;button @click=\"decrement\"&gt;-1&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: 'HelloVuex', computed: &#123; counter() &#123; return this.$store.state.counter &#125; &#125;, methods: &#123; increment() &#123; this.$store.commit('increment') &#125;, decrement() &#123; this.$store.commit('decrement') &#125; &#125;, &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 好的，这就是使用Vuex最简单的方式了。 我们来对使用步骤，做一个简单的小节： 1.提取出一个公共的store对象，用于保存在多个组件中共享的状态 2.将store对象放置在new Vue对象中，这样可以保证在所有的组件中都可以使用到 3.在其他组件中使用store对象中保存的状态即可 通过this.$store.state.属性的方式来访问状态 通过this.$store.commit(‘mutation中方法’)来修改状态 注意事项： 我们通过提交mutation的方式，而非直接改变store.state.count。 这是因为Vuex可以更明确的追踪状态的变化，所以不要直接改变store.state.count的值。 参考 coderwhy","categories":[],"tags":[{"name":"Vuex","slug":"Vuex","permalink":"http://www.xuweifeng.top/tags/Vuex/"},{"name":"Vue","slug":"Vue","permalink":"http://www.xuweifeng.top/tags/Vue/"}]},{"title":"Promise","slug":"Promise","date":"2020-02-26T15:44:04.000Z","updated":"2020-02-26T17:05:46.000Z","comments":true,"path":"2020/02/26/Promise/","link":"","permalink":"http://www.xuweifeng.top/2020/02/26/Promise/","excerpt":"","text":"Promise是什么？ Promise是异步编程的一种解决方案，ES6中一个非常重要和好用的特性。常见的使用场景是网络请求，当网络请求非常复杂时，就会出回调地狱(见下图) 夸张案例 然而Promise可以以一种非常优雅的方式来解决这个问题。 认识基本语法123456789101112//利用 setTimeout 来模拟 ajax 请求new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; // 成功调用 resolve('Hello world !') // 失败调用 reject(\"error message !\") &#125;,1000)&#125;).then(data =&gt; &#123; console.log(data);&#125;).catch(err =&gt; &#123; console.log(err);) 以上通过new Promise创建了一个Promise对象。 通常情况下，会根据请求数据的成功和失败来决定调用哪一个。 如果是成功的，那么通常会调用resolve(messsage)，这个时候，后续的then会被回调。 如果是失败的，那么通常会调用reject(error)，这个时候，后续的catch会被回调。 Promise的三种状态在我们开发中有异步操作时, 可以给异步操作包装一个Promise，异步操作之后会有三种状态。 pending：等待状态，比如正在进行网络请求，或者定时器没有到时间。 fulfill：满足状态，当主动回调了resolve时，就处于该状态，并且会回调.then()。 reject：拒绝状态，当主动回调了reject时，就处于该状态，并且会回调.catch()。 Promise的链式调用执行then还是catch的时候都可以返回一个Promise对象，代码是可以进行链式调用的。 Promise.resovle()：将数据包装成Promise对象，并且在内部回调resolve()函数。 Promise.reject()：将数据包装成Promise对象，并且在内部回调reject()函数。 Promis的all方法使用12345678910111213141516//发送两次或多次请求可用Promise.call方法 Promise.all([ new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#123;name:'abc', age:18&#125;) //可对象 可字符串 &#125;,2000) &#125;), new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve('result 2 !') //可对象 可字符串 &#125;,2000) &#125;), ]).then(results =&gt; &#123; console.log(results); //返回一个数组来保存 &#125;) 参考 coderwhy","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.xuweifeng.top/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://www.xuweifeng.top/tags/ES6/"}]},{"title":"Vue的生命周期","slug":"Vue的生命周期","date":"2020-02-25T11:37:20.000Z","updated":"2020-02-26T16:12:40.000Z","comments":true,"path":"2020/02/25/Vue的生命周期/","link":"","permalink":"http://www.xuweifeng.top/2020/02/25/Vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","excerpt":"","text":"生命周期图示 new Vue——&gt;创建一个vue实例 init()——&gt;初始化空的vue对象 beforecreate——&gt;data &amp; methods 还未初始化 created——&gt;data &amp; methods 已经初始化好，此时可调用methods方法、使用data中的数据(最早) compile template——&gt;编译模板在内存中生成DOM树，但此时未加载到页面上 beforeMount——&gt;模板尚未挂载至页面，页面仍未更新 create vm.$el &amp; replace el with it——&gt;将内存中编译好的模板替换至页面上,此时可操作页面Dom(最早) mounted——&gt;实例初始化加载完毕，进入运行阶段 beforeUpdate——&gt;data changed,data中数据已更新，页面上的数据仍未更新 virtual DOM re-render and patch——&gt;根据data的数据在内存中重新渲染新DOM树，更新完毕再将其渲染到页面- (model—&gt;view) updated——&gt;页面中的data更新了 beforeDestroy——&gt;运行—&gt;销毁，此时data/methods等仍可用，并未真正销毁 destroyed——&gt;everything is null","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://www.xuweifeng.top/tags/Vue/"},{"name":"前端框架","slug":"前端框架","permalink":"http://www.xuweifeng.top/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"}]},{"title":"邂逅Vuejs","slug":"邂逅Vuejs","date":"2020-02-25T10:30:26.000Z","updated":"2020-02-26T16:15:37.000Z","comments":true,"path":"2020/02/25/邂逅Vuejs/","link":"","permalink":"http://www.xuweifeng.top/2020/02/25/%E9%82%82%E9%80%85Vuejs/","excerpt":"","text":"简单认识Vuejs 为什么要学习Vuejs？ 招聘前端的需求中，10个有8个都对Vue有或多或少的要求。 当然，作为学习者我们知道Vuejs目前非常火，可以说是前端必备的一个技能。 近两年前端技术变革速度太快，vue不论针对web项目开发，网站制作，还是app，小程序开发，都越来越流行，其便捷性及易用程度都让你不得不考虑去学习。 Vuejs是什么？ Vue是一个渐进式的框架，那什么是渐进式的呢？ 渐进式意味着你可以将Vue作为你应用的一部分嵌入其中，带来更丰富的交互体验。 或者如果你希望将更多的业务逻辑使用Vue实现，那么Vue的核心库以及其生态系统。 比如Core+Vue-router+Vuex，也可以满足你各种各样的需求。 Vue有很多特点和Web开发中常见的高级功能 解耦视图和数据 可复用的组件 前端路由技术 状态管理 虚拟DOM 学习Vuejs的前提？ 需具备一定的HTML、CSS、JavaScript基础。 开始Vue.js之旅Vue.js安装使用一个框架之前我们要下载安装它。 方式一：直接CDN引入 12345&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt; &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;&lt;!-- 生产环境版本，优化了尺寸和速度 --&gt;&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue&quot;&gt;&lt;&#x2F;script&gt; 方式二：下载和引入 开发环境 https://vuejs.org/js/vue.js 生产环境 https://vuejs.org/js/vue.min.js 方式三：NPM安装","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://www.xuweifeng.top/tags/Vue/"},{"name":"前端框架","slug":"前端框架","permalink":"http://www.xuweifeng.top/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"}]},{"title":"关于搭建此博客","slug":"此博客的搭建","date":"2020-02-23T13:32:50.000Z","updated":"2020-02-26T16:08:46.000Z","comments":true,"path":"2020/02/23/此博客的搭建/","link":"","permalink":"http://www.xuweifeng.top/2020/02/23/%E6%AD%A4%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/","excerpt":"","text":"搭建前工作 写作工具 MarkDown Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。 语法简洁明了、学习容易，而且功能比纯文本更强。 搭建平台 Github Pages GitHub Pages旨在从GitHub存储库托管您的个人，组织或项目页面。 面对全球最大的开源社区,用户生态良好 国内访问速度慢 框架主题 Hexo Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 插件丰富,拓展性强 hexo-theme-material-indigo Material Design 风格的Hexo主题，基于 Hexo 3.0+ 制作。 去jQuery化以提高代码速度,更加相信现代浏览器的原生兼容性 准备工具 Git 用来管理博客代码 Node.js Hexo基于Node.js开发,下载Hexo及其主题与插件都需要用到其中的npm工具 开始搭建 所有的命令指令都需要在Hexo根目录下执行 安装hexo框架 打开命令行(管理者模式),通过npm工具下载hexo框架 npm install hexo-cli -g 创建一个blog文件夹,并在这个文件夹中初始化一个hexo框架 hexo init blog 进入blog文件夹,也就是整个Hexo站点的根目录 cd blog 安装hexo所需要的文件 npm install 启动hexo hexo server #简写 hexo s 通过http://localhost:4000/在浏览器中访问生成的博客 目录结构 _config.yml： //Hexo配置文件,网站的配置信息node_modules： //依赖包public： //存放生成的页面scaffolds： //生成文章的一些模板themes： //存放主题包source： //用来存放你的文章 _drafts： //草稿 _posts： //文章 Hexo配置 在文件根目录下的_config.yml文件配置，详细参考官方的配置描述。 indigo安装与配置 indigo安装 使用git命令，执行以下命令安装 git clone https://github.com/yscoder/hexo-theme-indigo.git 安装完打开themes文件夹可看见相对于的主题文件 打开根目录下的_config.yml对theme属性编辑 theme: indigo #这里填写的主题名字 在命令行输入hexo g 生成静态文件 再输入hexo s进行重启服务器 通过http://localhost:4000/在浏览器中访问生成的主题博客 indigo配置 修改主题目录下的_config.yml文件,详细可参考主题作者的配置说明描述。 部署到GitHub Pages hexo clean #清除本地缓存,也可以跳过这一步hexo generate #生成静态资源 简写:hexo ghexo deploy #部署资源 简写:hexo d","categories":[],"tags":[{"name":"Blog","slug":"Blog","permalink":"http://www.xuweifeng.top/tags/Blog/"}]}]}